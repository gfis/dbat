<?xml version="1.0" encoding="UTF-8"?>
<!--
    Transforms the descriptions of a stored Procedure's interface into a Java class
    suitable for calling this interface
    @(#) $Id$
    2011-12-16, Dr. Georg Fischer: copied from genRecord.xsl
-->
<!--
 * Copyright 2011 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<xsl:stylesheet version="1.0"
        xmlns:xsl ="http://www.w3.org/1999/XSL/Transform"
        xmlns:rec ="http://www.teherba.org/2007/dbat"
        xmlns:date="http://exslt.org/dates-and-times"
        xmlns:func="http://exslt.org/functions"
        extension-element-prefixes="func date"
        >
    <xsl:param name="package" /><!-- default: org.teherba.dbat -->
    <xsl:output method="text" /> <!-- i.e. Java source code -->
    <xsl:strip-space elements="*" /> <!-- remove whitespace in all nodes -->

    <xsl:variable name="spaces">
        <!-- 64 spaces for formatting -->
        <xsl:value-of select="'                                                                '" />
    </xsl:variable>

<!-- Transformation of the root element -->

    <xsl:template match="dbat">

        <xsl:variable name="className">
            <xsl:text>StoredProcedure</xsl:text>
        	<xsl:call-template name="uc1">
            	<xsl:with-param name="name" select="./create/@name" />
            </xsl:call-template>
        </xsl:variable>

        <!-- File header comment -->
        <xsl:value-of select="concat('/*  ', $className, '.java', '&#10;')" />
        <xsl:value-of select="concat(' *  @(#) $', 'Id$', '&#10;')" /> <!-- CVS inserts timestamp here -->
	<!--
        <xsl:value-of select="concat(' *  Automatically generated by etc/xslt/genSPCaller.xsl at ', date:date-time(), '&#10;')" />
    -->
        <xsl:value-of select="concat(' *  DO NOT EDIT HERE - rather inherit from this class!', '&#10;')" />
        <xsl:value-of select="concat(' */', '&#10;')" />

        <!-- Package and import statements -->
        <xsl:value-of select="concat('package ', @package, ';&#10;')" />
        <xsl:value-of select="concat('import  org.teherba.dbat.StoredProcedureCaller;', '&#10;')" />
        <xsl:choose>
            <xsl:when test="/rec:record/@type = 'Bean'">
            </xsl:when>
            <xsl:otherwise>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('import  java.sql.Date;', '&#10;')" />
        <xsl:value-of select="concat('import  java.sql.Timestamp;', '&#10;')" />
        <xsl:value-of select="concat('', '&#10;')" />

        <!-- Class declaration with javadoc -->
        <xsl:value-of select="concat('/** ', @rem, '.', '&#10;')" />
        <xsl:value-of select="concat(' *  total length ', @length, ' ', @type, 's', '&#10;')" />
        <xsl:value-of select="concat(' */', '&#10;')" />
        <xsl:value-of select="concat('public class ', $className, ' extends StoredProcedureCaller {', '&#10;')" />

        <!-- CVS string signature -->
        <xsl:value-of select="concat('    /** Source code version', ' */&#10;')" />
        <xsl:value-of select="concat('    public static final String CVSID = &quot;@(#) $', 'Id$&quot;;', '&#10;')" />
        <xsl:value-of select="concat('&#10;', '')" />

        <!-- Constructor -->
        <xsl:value-of select="concat('    /** No-args Constructor for ', @rem, '.', '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <xsl:value-of select="concat('    public ', $className, '() {&#10;')" />
        <xsl:value-of select="concat('        super();', '&#10;')" />
        <xsl:value-of select="concat('        setRecordTag(&quot;', @name, '&quot;);', '&#10;')" />
        <xsl:value-of select="concat('    } // Constructor', '&#10;&#10;')" />

        <!-- evaluate all substructures -->
        <xsl:for-each select="create/column">
            <xsl:apply-templates select="." />
        </xsl:for-each>

        <xsl:value-of select="concat('} // class ', $className, '&#10;')" />
    </xsl:template><!-- dbat -->

<!-- ======== templates for sub-elements ===================== -->

    <xsl:template match="rec:choice">
        <xsl:for-each select="rec:variant">
            <xsl:apply-templates select="." />
        </xsl:for-each>
    </xsl:template><!-- rec:choice -->

    <xsl:template match="rec:variant">
        <xsl:for-each select="rec:field|rec:choice|rec:array">
            <xsl:apply-templates select="." />
        </xsl:for-each>
    </xsl:template><!-- rec:variant -->

    <xsl:template match="rec:array">
        <!-- Generate field access code for the array element -->
        <xsl:if test="/rec:record/@type != 'Bean'">
            <xsl:call-template name="fieldBean">
                <xsl:with-param name="start"        select="@pos" />
                <xsl:with-param name="specType"     select="'String'" />
                <xsl:with-param name="javaType"     select="'String'" />
                <xsl:with-param name="dist"         select="@len" />
                <xsl:with-param name="occurs"       select="@occurs" />
            </xsl:call-template>
        </xsl:if>
        <xsl:for-each select="rec:field|rec:choice|rec:array">
            <xsl:apply-templates select="." />
        </xsl:for-each>
    </xsl:template><!-- rec:array -->

    <!-- set method and a get method for each field, using Char/ByteRecord access methods -->
    <xsl:template match="column">
        <xsl:call-template name="fieldBean">
            <xsl:with-param name="start"><!-- corresponding start position -->
                <xsl:choose>
                    <xsl:when test="string-length(../@pos) > 0">
                        <xsl:value-of select="@pos" />
                        <xsl:value-of select="concat(../@pos, ' + ', sum(./preceding-sibling::rec:field/@len))" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="sum(./preceding-sibling::rec:field/@len)" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="specType">
                <xsl:choose>
                    <xsl:when test="@type = 'binary'">
                        <xsl:value-of select="../@order" />
                    </xsl:when>
                    <xsl:when test="(@type = 'byte' and /rec:record/@type = 'Char') or @type='num'">
                        <xsl:value-of select="'Number'" />
                    </xsl:when>
                    <xsl:when test="@type = 'ebcdic'">
                        <xsl:value-of select="'EBCDICString'" />
                    </xsl:when>
                    <xsl:when test="@type = 'packed'">
                        <xsl:value-of select="'Decimal'" />
                    </xsl:when>
                    <xsl:when test="@type = 'unsignedpacked'">
                        <xsl:value-of select="'UnsignedDecimal'" />
                    </xsl:when>
                    <xsl:when test="@type = 'date'">
                        <xsl:value-of select="'Date'" />
                    </xsl:when>
                    <xsl:when test="@type = 'timestamp'">
                        <xsl:value-of select="'Timestamp'" />
                    </xsl:when>
                    <xsl:otherwise><!-- char or string -->
                        <xsl:value-of select="'String'" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="javaType">
                <xsl:choose>
                    <xsl:when test="(@type = 'byte' and /rec:record/@type = 'Char') or @type = 'num' or @type = 'binary'">
                        <xsl:value-of select="'long'" />
                    </xsl:when>
                    <xsl:when test="@type = 'date'">
                        <xsl:value-of select="'java.sql.Date'" />
                    </xsl:when>
                    <xsl:when test="@type = 'timestamp'">
                        <xsl:value-of select="'java.sql.Timestamp'" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="/rec:record/@type = 'Bean'">
                            <!--
                                <xsl:call-template name="uc1">
                                    <xsl:with-param name="name" select="@type"/>
                                </xsl:call-template>
                            -->
                                <xsl:value-of select="@type" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="'String'" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="dist" >
                <xsl:choose>
                    <xsl:when test="string-length(../@occurs) > 0">
                        <xsl:value-of select="../@len" />
                    </xsl:when>
                    <xsl:otherwise>

                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="occurs" select="../@occurs" />
        </xsl:call-template>
    </xsl:template><!-- rec:field -->

<!-- ======== auxiliary templates ===================== -->
    <xsl:template name="uc"> <!-- return name with all letters uppercased -->
        <xsl:param name="name"/>
        <xsl:value-of select="translate($name,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')" />
    </xsl:template>

    <xsl:template name="uc1"> <!-- return name with 1st letter uppercased -->
        <xsl:param name="name"/>
        <xsl:value-of select="concat(translate(substring($name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring($name,2))" />
    </xsl:template>

    <xsl:template name="fieldBean">
        <xsl:param name="start"     />
        <xsl:param name="javaType"  />
        <xsl:param name="specType"  />
        <xsl:param name="dist"      />
        <xsl:param name="occurs"    />

        <xsl:choose>
            <xsl:when test="/rec:record/@type = 'Bean'">
                <!-- Declaration of the bean property -->
                <xsl:value-of select="concat('    /** ', @name, ' - ', @rem, ' */', '&#10;')" />
                <xsl:value-of select="concat('    protected ', $javaType, ' ', @name)" />
                <xsl:if test="string-length($dist) > 0">
                    <xsl:value-of select="concat('[] = new ', $javaType, '[', $occurs, ']')" />
                </xsl:if>
                <xsl:value-of select="concat(';', '&#10;', '&#10;')" />
            </xsl:when>
            <xsl:otherwise>
                <!-- Static definition for the field with position, length and name -->
                <xsl:value-of select="concat('    /** Field ', @name, ' - ', @rem, ' */', '&#10;')" />
                <xsl:value-of select="concat('    protected static final Field ', '')" />
                <xsl:call-template name="uc">
                    <xsl:with-param name="name" select="@name" />
                </xsl:call-template>
                <xsl:value-of select="concat(' = new Field(', $start, ', ', @len, ', &quot;', @name, '&quot;);', '&#10;', '&#10;')" />
            </xsl:otherwise>
        </xsl:choose>

        <!-- javadoc for set method -->
        <xsl:value-of select="concat('    /** Sets ', @name, ' - ', @rem, '&#10;')" />
        <xsl:if test="string-length($dist) > 0">
            <xsl:value-of select="concat('     *  @param index index in array ', @aref, '&#10;')" />
        </xsl:if>
        <xsl:value-of select="concat('     *  @param ', @name, ' ', @rem, '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <!-- set method -->
        <xsl:value-of select="concat('    public void set', '')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name" />
        </xsl:call-template>
        <xsl:choose>
            <xsl:when test="string-length($dist) > 0">
                <xsl:value-of select="concat('(int index, ', $javaType, ' ', @name, ') {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        this.', @name, '[index] = ', @name, ';', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        set', $specType, '(', $start, ' + ', $dist, ' * index, ', @len, ', ', @name, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('(', $javaType, ' ', @name, ') {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        this.', @name, ' = ', @name, ';', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        set', $specType, '(', $start, ', ', @len, ', ', @name, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('    } // set', '')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name" />
        </xsl:call-template>
        <xsl:value-of select="concat('&#10;', '&#10;')" />

        <!-- javadoc for get method -->
        <xsl:value-of select="concat('    /** Gets ', @name, ' - ', @rem, '&#10;')" />
        <xsl:if test="string-length(@aref) > 0">
            <xsl:value-of select="concat('     *  @param index index in array ', @aref, '&#10;')" />
        </xsl:if>
        <xsl:value-of select="concat('     *  @return ', @rem, '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <!-- get method -->
        <xsl:value-of select="concat('    public ', $javaType, ' get')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name"/>
        </xsl:call-template>
        <xsl:choose>
            <xsl:when test="string-length($dist) > 0">
                <xsl:value-of select="concat('(int index) {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        return ', @name, '[index];', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        return get', $specType, '(', $start, ' + ', $dist, ' * index, ', @len, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('() {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        return ', @name, ';', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        return get', $specType, '(', $start, ', ', @len, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('    } // get', '')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name" />
        </xsl:call-template>
        <xsl:value-of select="concat('&#10;', '    //----------------', '&#10;')" />

    </xsl:template><!-- fieldBean -->

    <xsl:template name="fieldXML">
        <xsl:param name="index" />
        <xsl:variable name="FieldName">
            <xsl:call-template name="uc1">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="FIELDNAME">
            <xsl:call-template name="uc">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="spaces">
            <xsl:choose>
                <xsl:when test="string-length($FIELDNAME) &lt; 16" >
                    <xsl:value-of select="substring($spaces, 1, 16 - string-length($FIELDNAME))" />
                </xsl:when>
                <xsl:when test="string-length($FIELDNAME) &lt; 32">
                    <xsl:value-of select="substring($spaces, 1, 32 - string-length($FIELDNAME))" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="'                attrs.addAttribute('" />
        <xsl:value-of select="concat('&quot;&quot;, localName, &quot;', @name, '&quot;', $spaces)" />
        <xsl:value-of select="concat(', &quot;CDATA&quot;, ','')" />
        <xsl:choose>
            <xsl:when test="(@type = 'byte' and /rec:record/@type = 'Char') or @type = 'num' or @type = 'binary'">
                <xsl:value-of select="'Long.toString('" />
            </xsl:when>
            <xsl:when test="(@type = 'date')">
                <xsl:value-of select="'ISO_TIMESTAMP_FORMAT.format('" />
            </xsl:when>
            <xsl:when test="(@type = 'timestamp')">
                <xsl:value-of select="'ISO_DATE_FORMAT.format('" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type != 'String' and @type != 'string'">
                    <!--
                        <xsl:call-template name="uc1">
                            <xsl:with-param name="name" select="@type"/>
                        </xsl:call-template>
                    -->
                        <xsl:value-of select="concat('String.valueOf(', '')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="'replaceAttrText('" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('get', $FieldName, '(')" />
        <xsl:if test="string-length($index) &gt; 0">
            <xsl:value-of select="$index" />
        </xsl:if>
        <xsl:value-of select="concat(')));', '&#10;')" />
    </xsl:template><!-- fieldXML -->

    <xsl:template name="arrayXML">
        <xsl:variable name="index" select="concat('index', @name)" />
        <xsl:value-of select="concat('            int ', $index, ' = 0;', '&#10;')" />
        <xsl:value-of select="concat('            while (', $index, ' &lt; ', @count, ') {', '&#10;')" />
        <xsl:value-of select="concat('                attrs = new AttributesImpl();', '&#10;')" />
        <xsl:value-of select="concat('                attrs.addAttribute(', '&quot;&quot;')" />
        <xsl:value-of select="concat(', localName, &quot;index&quot;', '')" />
        <xsl:value-of select="concat(', &quot;CDATA&quot;, Integer.toString(index', @name, '));', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldXML">
                <xsl:with-param name="index" select="$index"/>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:value-of select="concat('                generator.fireEmptyElement(&quot;', @name, '&quot;, attrs);', '&#10;')" />
        <xsl:value-of select="concat('                ', $index, ' ++;', '&#10;')" />
        <xsl:value-of select="concat('            } // while', '&#10;')" />
    </xsl:template><!-- arrayXML -->

    <xsl:template name="variantSAX">
        <xsl:value-of select="concat('            } else if (qName.equals(&quot;', @name, '&quot;)) {', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldSAX">
                <xsl:with-param name="index" />
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template><!-- variantSAX -->

    <xsl:template name="arraySAX">
        <xsl:value-of select="concat('            } else if (qName.equals(&quot;', @name, '&quot;)) {', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldSAX">
                <xsl:with-param name="index" select="'Integer.parseInt(attrs.getValue(&quot;index&quot;))'"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template><!-- arraySAX -->

    <xsl:template name="fieldSAX">
        <xsl:param name="index" />
        <xsl:variable name="FieldName">
            <xsl:call-template name="uc1">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="FIELDNAME">
            <xsl:call-template name="uc">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="concat('                set', $FieldName)" />
        <xsl:choose>
            <xsl:when test="string-length($FIELDNAME) &lt; 16" >
                <xsl:value-of select="substring($spaces, 1, 16 - string-length($FIELDNAME))" />
            </xsl:when>
            <xsl:when test="string-length($FIELDNAME) &lt; 32">
                <xsl:value-of select="substring($spaces, 1, 32 - string-length($FIELDNAME))" />
            </xsl:when>
        </xsl:choose>
        <xsl:value-of select="'('" />
        <xsl:if test="string-length($index) &gt; 0">
            <xsl:value-of select="concat($index, ', ')" />
        </xsl:if>

        <xsl:variable name="attr" select="concat('attrs.getValue(&quot;', @name, '&quot;)')" />
        <xsl:choose>
            <xsl:when test="(@type = 'byte'      and /rec:record/@type = 'Char') or @type = 'num' or @type = 'binary'">
                <xsl:value-of select="concat('Long.parseLong(', $attr, ')')" />
            </xsl:when>
            <xsl:when test="(@type = 'date')">
                <xsl:value-of select="concat('new java.sql.Date     (ISO_DATE_FORMAT     .parse(', $attr, ').getTime())')" />
            </xsl:when>
            <xsl:when test="(@type = 'timestamp')">
                <xsl:value-of select="concat('new java.sql.Timestamp(ISO_TIMESTAMP_FORMAT.parse(', $attr, ').getTime())')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type = 'int'">
                        <xsl:value-of select="concat('Integer.parseInt(', $attr, ')')" />
                    </xsl:when>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type = 'long'">
                        <xsl:value-of select="concat('Long.parseLong(', $attr, ')')" />
                    </xsl:when>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type != 'String' and @type != 'string'">
                        <xsl:value-of select="concat(@type, '.valueOf(', $attr, ')')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat($attr, '')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat(');', '&#10;')" />

    </xsl:template><!-- fieldSAX -->

</xsl:stylesheet>
