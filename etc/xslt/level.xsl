<?xml version="1.0" encoding="UTF-8"?>
<!--
    Transforms a record structure definition into a Java class
    with field definitions, setters, getters, XML parser and serializer methods
    @(#) $Id: genRecord.xsl 9 2008-09-05 05:21:15Z gfis $
    2008-06-21: with <choice>, UTF-8 äöüÄÖÜß
    2007-11-11: protected properties instead of private ones
    2007-08-29: major revision, renamed from 'genBean.xsl', Bean repaired at various places
    2007-04-14: fewer <text> elements, no tabs anymore (4 spaces instead)
    2007-04-02: Attributes2Impl -> AttributesImpl
    2007-03-29: without xsl: prefix
    2007-01-24: for org.teherba
    2006-11-01: handling of date and timestamp for beans, also in SAX
    2006-09-27, Dr. Georg Fischer
-->
<!--
 * Copyright 2006 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<xsl:stylesheet version="1.0"
        xmlns:xsl ="http://www.w3.org/1999/XSL/Transform"
        xmlns:rec ="http://www.teherba.org/2006/xtrans/Record"
        xmlns:date="http://exslt.org/dates-and-times"
        xmlns:func="http://exslt.org/functions"
        extension-element-prefixes="func date"
        >
    <xsl:param name="package" /><!-- default: org.teherba.xtrans -->
    <xsl:output method="text" /> <!-- i.e. Java source code -->
    <xsl:strip-space elements="*" /> <!-- remove whitespace in all nodes -->

    <xsl:variable name="spaces">
        <!-- 64 spaces for formatting -->
        <xsl:value-of select="'                                                                '" />
    </xsl:variable>

<!-- Transformation of the root element -->

    <xsl:template match="rec:record">

        <xsl:variable name="className">
            <xsl:choose>
                <xsl:when test="/rec:record/@type = 'Bean'">
                    <xsl:value-of select="concat(@name, 'BeanBase')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="concat(@name, 'RecordBase')" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!-- File header comment -->
        <xsl:value-of select="concat('/*  ', $className, '.java - ', @rem, '&#10;')" />
        <xsl:value-of select="concat(' *  @(#) $', 'Id$', '&#10;')" /> <!-- CVS inserts timestamp here -->
        <xsl:value-of select="concat(' *  Automatically generated by etc/xslt/genRecord.xsl at ', date:date-time(), '&#10;')" />
        <xsl:value-of select="concat(' *  DO NOT EDIT HERE - rather inherit from this class!', '&#10;')" />
        <xsl:value-of select="concat(' */', '&#10;')" />

        <!-- Package and import statements -->
        <xsl:value-of select="concat('package ', @package, ';&#10;')" />
        <xsl:choose>
            <xsl:when test="/rec:record/@type = 'Bean'">
                <xsl:value-of select="concat('import  java.text.SimpleDateFormat;', '&#10;')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('import  org.teherba.xtrans.', @type, 'Record;', '&#10;')" />
                <xsl:value-of select="concat('import  org.teherba.xtrans.BaseTransformer;', '&#10;')" />
                <xsl:value-of select="concat('import  org.teherba.xtrans.Field;', '&#10;')" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('import  java.sql.Date;', '&#10;')" />
        <xsl:value-of select="concat('import  java.sql.Timestamp;', '&#10;')" />
        <xsl:value-of select="concat('import  org.xml.sax.Attributes;', '&#10;')" />
        <xsl:value-of select="concat('import  org.xml.sax.helpers.AttributesImpl;', '&#10;')" />
        <xsl:value-of select="concat('import  org.xml.sax.SAXException;', '&#10;')" />
        <xsl:value-of select="concat('', '&#10;')" />

        <!-- Class declaration with javadoc -->
        <xsl:value-of select="concat('/** ', @rem, '.', '&#10;')" />
        <xsl:choose>
            <xsl:when test="/rec:record/@type = 'Bean'">
                <xsl:value-of select="concat(' */', '&#10;')" />
                <xsl:value-of select="concat('public class ', $className, ' {', '&#10;')" />
                <xsl:text>    /** Readable format for dates */
    protected static final SimpleDateFormat ISO_DATE_FORMAT      = new SimpleDateFormat("yyyy-MM-dd");
    /** Readable format for timestamps with milliseconds */
    protected static final SimpleDateFormat ISO_TIMESTAMP_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");

    /** Replaces offending characters in attributes by entities,
     *  and trim right trailing whitespace
     *  @param value value of the attribute
     *  @return string with offending characters replaced by entities
     */
    protected String replaceAttrText(String value) {
        return ("x" + value
    			.replaceAll("&amp;" , "&amp;amp;")
                .replaceAll("\'", "&amp;apos;")
                .replaceAll("\"", "&amp;quot;")
               ).trim().substring(1);
    } // replaceAttrText

</xsl:text>
           </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat(' *  total length ', @length, ' ', @type, 's', '&#10;')" />
                <xsl:value-of select="concat(' */', '&#10;')" />
                <xsl:value-of select="concat('public class ', $className, ' extends ', @type, 'Record {', '&#10;')" />
                <!-- Constant for length of record -->
                <xsl:value-of select="concat('    public static final int RECORD_LENGTH = ', @length, ';', '&#10;')" />
            </xsl:otherwise>
        </xsl:choose>

        <!-- CVS string signature -->
        <xsl:value-of select="concat('    /** Source code version', ' */&#10;')" />
        <xsl:value-of select="concat('    public static final String CVSID = &quot;@(#) $', 'Id$&quot;;', '&#10;')" />
        <xsl:value-of select="concat('&#10;&#10;')" />

        <!-- Constructor -->
        <xsl:value-of select="concat('    /** No-args Constructor for ', @rem, '.', '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <xsl:value-of select="concat('    public ', $className, '() {&#10;')" />
        <xsl:value-of select="concat('        super();', '&#10;')" />
        <xsl:if test="/rec:record/@type != 'Bean'">
          <xsl:value-of select="concat('        setRecordTag(&quot;', @name, '&quot;);', '&#10;')" />
		</xsl:if>
        <xsl:value-of select="concat('    } // Constructor', '&#10;&#10;')" />

        <!-- evaluate all substructures -->
        <xsl:for-each select="rec:field|rec:choice|rec:array">
            <xsl:apply-templates select="." />
        </xsl:for-each>

<!-- private method replaceAttrText 
        <xsl:text>    /** Replaces offending characters in attributes by entities
     *  @param value value of the attribute
     *  @return string with offending characters replaced by entities
     */
    private String replaceAttrText(String value) {
        return value
                .replaceAll("&amp;" , "&amp;amp;")
                .replaceAll("\&apos;", "&amp;apos;")
                .replaceAll("\&quot;", "&amp;quot;")
                ;
    } // replaceAttrText

</xsl:text>
-->
        <!-- javadoc for getXMLTag -->
        <xsl:value-of select="'&#10;'" />
        <xsl:value-of select="concat('    /** Gets an XML tag for the record', '&#10;')" />
        <xsl:value-of select="concat('     *  @param namespace namespace for the generated XML tag with colon, or empty', '&#10;')" />
        <xsl:value-of select="concat('     *  @return an XML element for a ', @name, ' record', '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <!-- method getXMLTag -->
        <xsl:value-of select="concat('    public String getXMLTag(String namespace)', ' {', '&#10;')" />
        <xsl:value-of select="concat('        return namespace + &quot;', @name, '&quot;;', '&#10;')" />
        <xsl:value-of select="concat('    } // getXMLTag', '&#10;', '&#10;')" />

        <xsl:choose>
            <xsl:when test="/rec:record/@type = 'Bean'">
                <!-- javadoc for getAttributes -->
                <xsl:value-of select="concat('    /** Assembles all attributes in an object', '&#10;')" />
                <xsl:value-of select="concat('     *  @return attributes for an XML element representing the bean', '&#10;')" />
                <xsl:value-of select="concat('     */', '&#10;')" />
                <!-- method getAttributes -->
                <xsl:value-of select="concat('    public Attributes getAttributes()', ' {', '&#10;')" />
                <xsl:value-of select="concat('        String localName = &quot;&quot;;', '&#10;')" />
                <xsl:value-of select="concat('        AttributesImpl attrs = null;', '&#10;')" />
                <xsl:value-of select="concat('        attrs = new AttributesImpl();', '&#10;')" />
                <xsl:for-each select="rec:field">
                    <xsl:call-template name="fieldXML">
                        <xsl:with-param name="index" select="" />
                    </xsl:call-template>
                </xsl:for-each>
                <xsl:value-of select="concat('        return attrs;', '&#10;', '&#10;')" />
                <xsl:value-of select="concat('    } // getAttributes', '&#10;', '&#10;')" />
            </xsl:when>
            <xsl:otherwise>
                <!-- javadoc for fireElements -->
                <xsl:value-of select="concat('    /** Fires several SAX events for the record', '&#10;')" />
                <xsl:value-of select="concat('     *  @param generator transformer with SAX event firing  methods', '&#10;')" />
                <xsl:value-of select="concat('     */', '&#10;')" />
                <!-- method fireElements -->
                <xsl:value-of select="concat('    public void fireElements(BaseTransformer generator)', ' {', '&#10;')" />
                <xsl:value-of select="concat('        String localName = &quot;&quot;;', '&#10;')" />
                <xsl:value-of select="concat('        AttributesImpl attrs = null;', '&#10;')" />
                <xsl:value-of select="concat('        attrs = new AttributesImpl();', '&#10;')" />
                <xsl:for-each select="rec:field">
                    <xsl:call-template name="fieldXML">
                        <xsl:with-param name="index" />
                    </xsl:call-template>
                </xsl:for-each>
                <xsl:value-of select="concat('        generator.fireStartElement(&quot;', @name, '&quot;, attrs);', '&#10;')" />

                <xsl:for-each select="rec:array">
                    <xsl:call-template name="arrayXML" />
                </xsl:for-each>
                <xsl:if test="count(rec:choice) > 0">
                    <xsl:value-of select="concat('        if (false) {', '&#10;')" />
                    <xsl:for-each select="rec:choice/rec:variant">
                        <xsl:variable name="FieldName">
                            <xsl:call-template name="uc1">
                                <xsl:with-param name="name" select="@test"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:value-of select="concat('        } else if (get', $FieldName, '().equals(&quot;', @value, '&quot;)) {', '&#10;')" />
                        <xsl:value-of select="concat('            attrs = new AttributesImpl();', '&#10;')" />
                        <xsl:for-each select="rec:field">
                            <xsl:call-template name="fieldXML" />
                        </xsl:for-each>

                        <xsl:choose>
                            <xsl:when test="count(rec:array) > 0">
                                <xsl:value-of select="concat('            generator.fireStartElement(&quot;', @name, '&quot;, attrs);', '&#10;')" />
                                <xsl:for-each select="rec:array">
                                    <xsl:call-template name="arrayXML" />
                                </xsl:for-each>
                                <xsl:value-of select="concat('            generator.fireEndElement(&quot;', @name, '&quot;);', '&#10;')" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat('            generator.fireEmptyElement(&quot;', @name, '&quot;, attrs);', '&#10;')" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                    <xsl:value-of select="concat('        }', '&#10;')" />
                </xsl:if>
                <xsl:value-of select="concat('        generator.fireEndElement(&quot;', @name, '&quot;);', '&#10;')" />
                <xsl:value-of select="concat('    } // fireElements', '&#10;', '&#10;')" />
            </xsl:otherwise>
        </xsl:choose>

        <!-- SAX handler methods -->
        <xsl:text>    /** Receive notification of the start of an element.
     *  Looks for the element which contains encoded strings.
     *  @param uri The Namespace URI, or the empty string if the element has no Namespace URI
     *  or if Namespace processing is not being performed.
     *  @param localName the local name (without prefix),
     *  or the empty string if Namespace processing is not being performed.
     *  @param qName the qualified name (with prefix),
     *  or the empty string if qualified names are not available.
     *  @param attrs the attributes attached to the element.
     *  If there are no attributes, it shall be an empty Attributes object.
     *  @throws SAX Exception
     */
    public void startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException {
        try {
            if (false) {
</xsl:text>
        <xsl:value-of select="concat('            } else if (qName.equals(&quot;', @name, '&quot;)) {', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldSAX" />
        </xsl:for-each>

        <xsl:for-each select=".//rec:variant">
            <xsl:call-template name="variantSAX" />
        </xsl:for-each>

        <xsl:for-each select=".//rec:array">
            <xsl:call-template name="arraySAX" />
        </xsl:for-each>

        <xsl:text>            } else {
                // silently ignore other elements
            }
        } catch (Exception exc) {
            throw new SAXException("invalid attribute value ", exc);
        }
    } // startElement
    
</xsl:text>
        <xsl:value-of select="concat('} // class ', $className, '&#10;')" />
    </xsl:template><!-- rec:record -->

<!-- ======== templates for sub-elements ===================== -->

    <xsl:template match="rec:choice">
        <xsl:for-each select="rec:variant">
            <xsl:apply-templates select="." />
        </xsl:for-each>
    </xsl:template><!-- rec:choice -->

    <xsl:template match="rec:variant">
        <xsl:for-each select="rec:field|rec:choice|rec:array">
            <xsl:apply-templates select="." />
        </xsl:for-each>
    </xsl:template><!-- rec:variant -->

    <xsl:template match="rec:array">
        <!-- Generate field access code for the array element -->
        <xsl:if test="/rec:record/@type != 'Bean'">
            <xsl:call-template name="fieldBean">
                <xsl:with-param name="start"        select="@pos" />
                <xsl:with-param name="specType"     select="'String'" />
                <xsl:with-param name="javaType"     select="'String'" />
                <xsl:with-param name="dist"         select="@len" />
                <xsl:with-param name="occurs"       select="@occurs" />
            </xsl:call-template>
        </xsl:if>
        <xsl:for-each select="rec:field|rec:choice|rec:array">
            <xsl:apply-templates select="." />
        </xsl:for-each>
    </xsl:template><!-- rec:array -->

    <!-- set method and a get method for each field, using Char/ByteRecord access methods -->
    <xsl:template match="rec:field">
        <xsl:call-template name="fieldBean">
            <xsl:with-param name="start"><!-- corresponding start position -->
                <xsl:choose>
                    <xsl:when test="string-length(../@pos) > 0">
                        <xsl:value-of select="@pos" />
                        <xsl:value-of select="concat(../@pos, ' + ', sum(./preceding-sibling::rec:field/@len))" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="sum(./preceding-sibling::rec:field/@len)" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="specType">
                <xsl:choose>
                    <xsl:when test="@type = 'binary'">
                        <xsl:value-of select="../@order" />
                    </xsl:when>
                    <xsl:when test="(@type = 'byte' and /rec:record/@type = 'Char') or @type='num'">
                        <xsl:value-of select="'Number'" />
                    </xsl:when>
                    <xsl:when test="@type = 'ebcdic'">
                        <xsl:value-of select="'EBCDICString'" />
                    </xsl:when>
                    <xsl:when test="@type = 'packed'">
                        <xsl:value-of select="'Decimal'" />
                    </xsl:when>
                    <xsl:when test="@type = 'unsignedpacked'">
                        <xsl:value-of select="'UnsignedDecimal'" />
                    </xsl:when>
                    <xsl:when test="@type = 'date'">
                        <xsl:value-of select="'Date'" />
                    </xsl:when>
                    <xsl:when test="@type = 'timestamp'">
                        <xsl:value-of select="'Timestamp'" />
                    </xsl:when>
                    <xsl:otherwise><!-- char or string -->
                        <xsl:value-of select="'String'" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="javaType">
                <xsl:choose>
                    <xsl:when test="(@type = 'byte' and /rec:record/@type = 'Char') or @type = 'num' or @type = 'binary'">
                        <xsl:value-of select="'long'" />
                    </xsl:when>
                    <xsl:when test="@type = 'date'">
                        <xsl:value-of select="'java.sql.Date'" />
                    </xsl:when>
                    <xsl:when test="@type = 'timestamp'">
                        <xsl:value-of select="'java.sql.Timestamp'" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="/rec:record/@type = 'Bean'">
                            <!--
                                <xsl:call-template name="uc1">
                                    <xsl:with-param name="name" select="@type"/>
                                </xsl:call-template>
                            -->
                                <xsl:value-of select="@type" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="'String'" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="dist" >
                <xsl:choose>
                    <xsl:when test="string-length(../@occurs) > 0">
                        <xsl:value-of select="../@len" />
                    </xsl:when>
                    <xsl:otherwise>

                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="occurs" select="../@occurs" /> >
        </xsl:call-template>
    </xsl:template><!-- rec:field -->

<!-- ======== auxiliary templates ===================== -->
    <xsl:template name="uc"> <!-- return name with all letters uppercased -->
        <xsl:param name="name"/>
        <xsl:value-of select="translate($name,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')" />
    </xsl:template>

    <xsl:template name="uc1"> <!-- return name with 1st letter uppercased -->
        <xsl:param name="name"/>
        <xsl:value-of select="concat(translate(substring($name,1,1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'),substring($name,2))" />
    </xsl:template>

    <xsl:template name="fieldBean">
        <xsl:param name="start"     />
        <xsl:param name="javaType"  />
        <xsl:param name="specType"  />
        <xsl:param name="dist"      />
        <xsl:param name="occurs"    />

        <xsl:choose>
            <xsl:when test="/rec:record/@type = 'Bean'">
                <!-- Declaration of the bean property -->
                <xsl:value-of select="concat('    /** ', @name, ' - ', @rem, ' */', '&#10;')" />
                <xsl:value-of select="concat('    protected ', $javaType, ' ', @name)" />
                <xsl:if test="string-length($dist) > 0">
                    <xsl:value-of select="concat('[] = new ', $javaType, '[', $occurs, ']')" />
                </xsl:if>
                <xsl:value-of select="concat(';', '&#10;', '&#10;')" />
            </xsl:when>
            <xsl:otherwise>
                <!-- Static definition for the field with position, length and name -->
                <xsl:value-of select="concat('    /** Field ', @name, ' - ', @rem, ' */', '&#10;')" />
                <xsl:value-of select="concat('    protected static final Field ', '')" />
                <xsl:call-template name="uc">
                    <xsl:with-param name="name" select="@name" />
                </xsl:call-template>
                <xsl:value-of select="concat(' = new Field(', $start, ', ', @len, ', &quot;', @name, '&quot;);', '&#10;', '&#10;')" />
            </xsl:otherwise>
        </xsl:choose>

        <!-- javadoc for set method -->
        <xsl:value-of select="concat('    /** Sets ', @name, ' - ', @rem, '&#10;')" />
        <xsl:if test="string-length($dist) > 0">
            <xsl:value-of select="concat('     *  @param index index in array ', @aref, '&#10;')" />
        </xsl:if>
        <xsl:value-of select="concat('     *  @param ', @name, ' ', @rem, '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <!-- set method -->
        <xsl:value-of select="concat('    public void set', '')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name" />
        </xsl:call-template>
        <xsl:choose>
            <xsl:when test="string-length($dist) > 0">
                <xsl:value-of select="concat('(int index, ', $javaType, ' ', @name, ') {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        this.', @name, '[index] = ', @name, ';', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        set', $specType, '(', $start, ' + ', $dist, ' * index, ', @len, ', ', @name, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('(', $javaType, ' ', @name, ') {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        this.', @name, ' = ', @name, ';', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        set', $specType, '(', $start, ', ', @len, ', ', @name, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('    } // set', '')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name" />
        </xsl:call-template>
        <xsl:value-of select="concat('&#10;', '&#10;')" />

        <!-- javadoc for get method -->
        <xsl:value-of select="concat('    /** Gets ', @name, ' - ', @rem, '&#10;')" />
        <xsl:if test="string-length(@aref) > 0">
            <xsl:value-of select="concat('     *  @param index index in array ', @aref, '&#10;')" />
        </xsl:if>
        <xsl:value-of select="concat('     *  @return ', @rem, '&#10;')" />
        <xsl:value-of select="concat('     */', '&#10;')" />
        <!-- get method -->
        <xsl:value-of select="concat('    public ', $javaType, ' get')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name"/>
        </xsl:call-template>
        <xsl:choose>
            <xsl:when test="string-length($dist) > 0">
                <xsl:value-of select="concat('(int index) {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        return ', @name, '[index];', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        return get', $specType, '(', $start, ' + ', $dist, ' * index, ', @len, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('() {', '&#10;')" />
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean'">
                        <xsl:value-of select="concat('        return ', @name, ';', '&#10;')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('        return get', $specType, '(', $start, ', ', @len, ');', '&#10;')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('    } // get', '')" />
        <xsl:call-template name="uc1">
            <xsl:with-param name="name" select="@name" />
        </xsl:call-template>
        <xsl:value-of select="concat('&#10;', '    //----------------', '&#10;')" />

    </xsl:template><!-- fieldBean -->

    <xsl:template name="fieldXML">
        <xsl:param name="index" />
        <xsl:variable name="FieldName">
            <xsl:call-template name="uc1">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="FIELDNAME">
            <xsl:call-template name="uc">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="spaces">
            <xsl:choose>
                <xsl:when test="string-length($FIELDNAME) &lt; 16" >
                    <xsl:value-of select="substring($spaces, 1, 16 - string-length($FIELDNAME))" />
                </xsl:when>
                <xsl:when test="string-length($FIELDNAME) &lt; 32">
                    <xsl:value-of select="substring($spaces, 1, 32 - string-length($FIELDNAME))" />
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="'                attrs.addAttribute('" />
        <xsl:value-of select="concat('&quot;&quot;, localName, &quot;', @name, '&quot;', $spaces)" />
        <xsl:value-of select="concat(', &quot;CDATA&quot;, ','')" />
        <xsl:choose>
            <xsl:when test="(@type = 'byte' and /rec:record/@type = 'Char') or @type = 'num' or @type = 'binary'">
                <xsl:value-of select="'Long.toString('" />
            </xsl:when>
            <xsl:when test="(@type = 'date')">
                <xsl:value-of select="'ISO_TIMESTAMP_FORMAT.format('" />
            </xsl:when>
            <xsl:when test="(@type = 'timestamp')">
                <xsl:value-of select="'ISO_DATE_FORMAT.format('" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type != 'String' and @type != 'string'">
                    <!--
                        <xsl:call-template name="uc1">
                            <xsl:with-param name="name" select="@type"/>
                        </xsl:call-template>
                    -->
                        <xsl:value-of select="concat('String.valueOf(', '')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="'replaceAttrText('" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat('get', $FieldName, '(')" />
        <xsl:if test="string-length($index) &gt; 0">
            <xsl:value-of select="$index" />
        </xsl:if>
        <xsl:value-of select="concat(')));', '&#10;')" />
    </xsl:template><!-- fieldXML -->

    <xsl:template name="arrayXML">
        <xsl:variable name="index" select="concat('index', @name)" />
        <xsl:value-of select="concat('            int ', $index, ' = 0;', '&#10;')" />
        <xsl:value-of select="concat('            while (', $index, ' &lt; ', @count, ') {', '&#10;')" />
        <xsl:value-of select="concat('                attrs = new AttributesImpl();', '&#10;')" />
        <xsl:value-of select="concat('                attrs.addAttribute(', '&quot;&quot;')" />
        <xsl:value-of select="concat(', localName, &quot;index&quot;', '')" />
        <xsl:value-of select="concat(', &quot;CDATA&quot;, Integer.toString(index', @name, '));', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldXML">
                <xsl:with-param name="index" select="$index"/>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:value-of select="concat('                generator.fireEmptyElement(&quot;', @name, '&quot;, attrs);', '&#10;')" />
        <xsl:value-of select="concat('                ', $index, ' ++;', '&#10;')" />
        <xsl:value-of select="concat('            } // while', '&#10;')" />
    </xsl:template><!-- arrayXML -->

    <xsl:template name="variantSAX">
        <xsl:value-of select="concat('            } else if (qName.equals(&quot;', @name, '&quot;)) {', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldSAX">
                <xsl:with-param name="index" />
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template><!-- variantSAX -->

    <xsl:template name="arraySAX">
        <xsl:value-of select="concat('            } else if (qName.equals(&quot;', @name, '&quot;)) {', '&#10;')" />
        <xsl:for-each select="rec:field">
            <xsl:call-template name="fieldSAX">
                <xsl:with-param name="index" select="'Integer.parseInt(attrs.getValue(&quot;index&quot;))'"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template><!-- arraySAX -->

    <xsl:template name="fieldSAX">
        <xsl:param name="index" />
        <xsl:variable name="FieldName">
            <xsl:call-template name="uc1">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="FIELDNAME">
            <xsl:call-template name="uc">
                <xsl:with-param name="name" select="@name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="concat('                set', $FieldName)" />
        <xsl:choose>
            <xsl:when test="string-length($FIELDNAME) &lt; 16" >
                <xsl:value-of select="substring($spaces, 1, 16 - string-length($FIELDNAME))" />
            </xsl:when>
            <xsl:when test="string-length($FIELDNAME) &lt; 32">
                <xsl:value-of select="substring($spaces, 1, 32 - string-length($FIELDNAME))" />
            </xsl:when>
        </xsl:choose>
        <xsl:value-of select="'('" />
        <xsl:if test="string-length($index) &gt; 0">
            <xsl:value-of select="concat($index, ', ')" />
        </xsl:if>

        <xsl:variable name="attr" select="concat('attrs.getValue(&quot;', @name, '&quot;)')" />
        <xsl:choose>
            <xsl:when test="(@type = 'byte'      and /rec:record/@type = 'Char') or @type = 'num' or @type = 'binary'">
                <xsl:value-of select="concat('Long.parseLong(', $attr, ')')" />
            </xsl:when>
            <xsl:when test="(@type = 'date')">
                <xsl:value-of select="concat('new java.sql.Date     (ISO_DATE_FORMAT     .parse(', $attr, ').getTime())')" />
            </xsl:when>
            <xsl:when test="(@type = 'timestamp')">
                <xsl:value-of select="concat('new java.sql.Timestamp(ISO_TIMESTAMP_FORMAT.parse(', $attr, ').getTime())')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type = 'int'">
                        <xsl:value-of select="concat('Integer.parseInt(', $attr, ')')" />
                    </xsl:when>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type = 'long'">
                        <xsl:value-of select="concat('Long.parseLong(', $attr, ')')" />
                    </xsl:when>
                    <xsl:when test="/rec:record/@type = 'Bean' and @type != 'String' and @type != 'string'">
                        <xsl:value-of select="concat(@type, '.valueOf(', $attr, ')')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat($attr, '')" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="concat(');', '&#10;')" />

    </xsl:template><!-- fieldSAX -->

</xsl:stylesheet>
